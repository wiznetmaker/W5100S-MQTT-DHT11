/**

 * Copyright (c) 2021 WIZnet Co.,Ltd

 *

 * SPDX-License-Identifier: BSD-3-Clause

 */

// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// --- //
// dht //
// --- //

#define dht_wrap_target 0
#define dht_wrap 16

#define dht_start_signal_clocks_per_loop 1
#define dht_pulse_measurement_clocks_per_loop 2

static const uint16_t dht_program_instructions[] = {
    //     .wrap_target
    0x0080, //  0: jmp    y--, 0
    0xe080, //  1: set    pindirs, 0
    0x00c2, //  2: jmp    pin, 2
    0x00c5, //  3: jmp    pin, 5
    0x0003, //  4: jmp    3
    0x00c5, //  5: jmp    pin, 5
    0x00c8, //  6: jmp    pin, 8
    0x0006, //  7: jmp    6
    0xa047, //  8: mov    y, osr
    0x00cb, //  9: jmp    pin, 11
    0x000f, // 10: jmp    15
    0x0089, // 11: jmp    y--, 9
    0xe021, // 12: set    x, 1
    0x4021, // 13: in     x, 1
    0x0005, // 14: jmp    5
    0x4061, // 15: in     null, 1
    0x0006, // 16: jmp    6
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program dht_program = {
    .instructions = dht_program_instructions,
    .length = 17,
    .origin = -1,
};

static inline pio_sm_config dht_program_get_default_config(uint offset)
{
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + dht_wrap_target, offset + dht_wrap);
    return c;
}
#endif

/**

 * ----------------------------------------------------------------------------------------------------

 * Includes

 * ----------------------------------------------------------------------------------------------------

 */

#include <stdio.h>

#include <string.h>

#include <pico/stdlib.h> //related to dht

#include "port_common.h"

#include "wizchip_conf.h"

#include "w5x00_spi.h"

#include "mqtt_interface.h"

#include "MQTTClient.h"

#include "timer.h"

#include <hardware/pio.h>

#include <stdint.h>

#include <hardware/clocks.h>

#include <hardware/dma.h>

#include <math.h>

#include <string.h>

#ifndef _DHT_H_

#define _DHT_H_

#ifdef __cplusplus

extern "C"
{

#endif

    /** \file dht.h

     *

     * \brief DHT sensor library.

     */

    /**

     * \brief DHT sensor model.

     */

    typedef enum dht_model_t
    {

        DHT11,

        DHT12,

        DHT21,

        DHT22,

    } dht_model_t;

    /**

     * \brief DHT sensor.

     */

    typedef struct dht_t
    {

        PIO pio;

        uint8_t model;

        uint8_t pio_program_offset;

        uint8_t sm;

        uint8_t dma_chan;

        uint8_t data_pin;

        uint8_t data[5];

        uint32_t start_time;

    } dht_t;

    /**

     * \brief Measurement result.

     */

    typedef enum dht_result_t
    {

        DHT_RESULT_OK, /**< No error.*/

        DHT_RESULT_TIMEOUT, /**< DHT sensor not reponding. */

        DHT_RESULT_BAD_CHECKSUM, /**< Sensor data doesn't match checksum. */

    } dht_result_t;

    /**

     * \brief Initialize DHT sensor.

     *

     * The library claims one state machine from the given PIO instance, and one DMA

     * channel to communicate with the sensor.

     *

     * \param dht DHT sensor.

     * \param model DHT sensor model.

     * \param pio PIO block to use (pio0 or pio1).

     * \param data_pin Sensor data pin.

     * \param pull_up Whether to enable the internal pull-up.

     */

    void dht_init(dht_t *dht, dht_model_t model, PIO pio, uint8_t data_pin, bool pull_up);

    /**

     * \brief Deinitialize DHT sensor.

     *

     * \param dht DHT sensor.

     */

    void dht_deinit(dht_t *dht);

    /**

     * \brief Start asynchronous measurement.

     *

     * The measurement runs in the background, and may take up to 25ms depending

     * on DHT model.

     *

     * DHT sensors typically need at least 2 seconds between measurements for

     * accurate results.

     *

     * \param dht DHT sensor.

     */

    void dht_start_measurement(dht_t *dht);

    /**

     * \brief Wait for measurement to complete and get the result.

     *

     * \param dht DHT sensor.

     * \param[out] humidity Relative humidity. May be NULL.

     * \param[out] temperature_c Degrees Celsius. May be NULL.

     * \return Result status.

     */

    dht_result_t dht_finish_measurement_blocking(dht_t *dht, float *humidity, float *temperature_c);

#ifdef __cplusplus
}

#endif

#endif // _DHT_H_

static const uint PIO_SM_CLOCK_FREQUENCY = 1000000; // 1MHz

static const uint DHT_LONG_PULSE_THRESHOLD_US = 50;

static const uint DHT_MEASUREMENT_TIMEOUT_US = 6000;

//

// misc

//

static uint get_start_pulse_duration_us(dht_model_t model)
{

    return (model == DHT21 || model == DHT22) ? 1000 : 18000;
}

static uint get_pio_sm_clocks(uint us)
{

    float clocks_per_microsecond = PIO_SM_CLOCK_FREQUENCY / 1000000.0f;

    return roundf(us * clocks_per_microsecond);
}

static bool pio_sm_is_enabled(PIO pio, uint sm)
{

    return (pio->ctrl & (1 << sm)) != 0;
}

static void dht_program_init(PIO pio, uint sm, uint offset, dht_model_t model, uint data_pin)
{

    pio_sm_config c = dht_program_get_default_config(offset);

    uint32_t sys_clock_frequency = clock_get_hz(clk_sys);

    sm_config_set_clkdiv(&c, sys_clock_frequency / (float)PIO_SM_CLOCK_FREQUENCY);

    sm_config_set_set_pins(&c, data_pin, 1);

    // configuring jmp pin is enough, we don't need any other input pins

    sm_config_set_jmp_pin(&c, data_pin);

    // bits arrive in MSB order and are shifted to the left; autopush every 8 bits

    sm_config_set_in_shift(&c, false /* shift_right */, true /* autopush */, 8 /* push_threshold */);

    pio_sm_init(pio, sm, offset, &c);

    // push timing values

    pio_sm_put_blocking(pio, sm, get_pio_sm_clocks(get_start_pulse_duration_us(model) / dht_start_signal_clocks_per_loop));

    pio_sm_put_blocking(pio, sm, get_pio_sm_clocks(DHT_LONG_PULSE_THRESHOLD_US / dht_pulse_measurement_clocks_per_loop));

    // drive the data pin low to wake sensor

    pio_sm_exec(pio, sm, pio_encode_set(pio_pindirs, 1));

    // pull the start-signal duration

    pio_sm_exec(pio, sm, pio_encode_pull(/* if_empty */ false, /* block */ true));

    // store it in Y register for the loop

    pio_sm_exec(pio, sm, pio_encode_mov(pio_y, pio_osr));

    // pull the long pulse threshold

    pio_sm_exec(pio, sm, pio_encode_pull(/* if_empty */ false, /* block */ true));

    // start executing the PIO program

    pio_sm_set_enabled(pio, sm, true);
}

static void configure_dma_channel(uint chan, PIO pio, uint sm, uint8_t *write_addr)
{

    dma_channel_config c = dma_channel_get_default_config(chan);

    channel_config_set_dreq(&c, pio_get_dreq(pio, sm, false /* is_tx */));

    channel_config_set_irq_quiet(&c, true);

    channel_config_set_transfer_data_size(&c, DMA_SIZE_8);

    channel_config_set_read_increment(&c, false);

    channel_config_set_write_increment(&c, true);

    dma_channel_configure(chan, &c, write_addr, &pio->rxf[sm], 5, true /* trigger */);
}

static float decode_temperature(dht_model_t model, uint8_t b0, uint8_t b1)
{

    float temperature;

    switch (model)
    {

    case DHT11:

        if (b1 & 0x80)
        {

            // below-zero temperature not supported

            temperature = 0.0f;
        }
        else
        {

            temperature = b0 + 0.1f * (b1 & 0x7F);
        }

        break;

    case DHT12:

        temperature = b0 + 0.1f * (b1 & 0x7F);

        if (b1 & 0x80)
        {

            temperature = -temperature;
        }

        break;

    case DHT21:

    case DHT22:

        temperature = 0.1f * (((b0 & 0x7F) << 8) + b1);

        if (b0 & 0x80)
        {

            temperature = -temperature;
        }

        break;

    default:

        assert(false); // invalid model
    }

    return temperature;
}

static float decode_humidity(dht_model_t model, uint8_t b0, uint8_t b1)
{

    float humidity;

    switch (model)
    {

    case DHT11:

    case DHT12:

        humidity = b0 + 0.1f * b1;

        break;

    case DHT21:

    case DHT22:

        humidity = 0.1f * ((b0 << 8) + b1);

        break;

    default:

        assert(false); // invalid model
    }

    return humidity;
}

//

// public interface

//

void dht_init(dht_t *dht, dht_model_t model, PIO pio, uint8_t data_pin, bool pull_up)
{

    assert(pio == pio0 || pio == pio1);

    memset(dht, 0, sizeof(dht_t));

    dht->model = model;

    dht->pio = pio;

    dht->pio_program_offset = pio_add_program(pio, &dht_program);

    dht->sm = pio_claim_unused_sm(pio, true /* required */);

    dht->dma_chan = dma_claim_unused_channel(true /* required */);

    dht->data_pin = data_pin;

    pio_gpio_init(pio, data_pin);

    gpio_set_pulls(data_pin, pull_up, false /* down */);
}

void dht_deinit(dht_t *dht)
{

    assert(dht->pio != NULL); // not initialized

    dma_channel_abort(dht->dma_chan);

    dma_channel_unclaim(dht->dma_chan);

    pio_sm_set_enabled(dht->pio, dht->sm, false);

    // make sure pin is left in hi-z mode; original pin function & pulls are not restored

    pio_sm_set_consecutive_pindirs(dht->pio, dht->sm, dht->data_pin, 1, false /* is_out */);

    pio_sm_unclaim(dht->pio, dht->sm);

    pio_remove_program(dht->pio, &dht_program, dht->pio_program_offset);

    dht->pio = NULL;
}

void dht_start_measurement(dht_t *dht)
{

    assert(dht->pio != NULL); // not initialized

    assert(!pio_sm_is_enabled(dht->pio, dht->sm)); // another measurement in progress

    memset(dht->data, 0, sizeof(dht->data));

    configure_dma_channel(dht->dma_chan, dht->pio, dht->sm, dht->data);

    dht_program_init(dht->pio, dht->sm, dht->pio_program_offset, dht->model, dht->data_pin);

    dht->start_time = time_us_32();
}

dht_result_t dht_finish_measurement_blocking(dht_t *dht, float *humidity, float *temperature_c)
{

    assert(dht->pio != NULL); // not initialized

    assert(pio_sm_is_enabled(dht->pio, dht->sm)); // no measurement in progress

    uint32_t timeout = get_start_pulse_duration_us(dht->model) + DHT_MEASUREMENT_TIMEOUT_US;

    while (dma_channel_is_busy(dht->dma_chan) && time_us_32() - dht->start_time < timeout)
    {

        tight_loop_contents();
    }

    pio_sm_set_enabled(dht->pio, dht->sm, false);

    // make sure pin is left in hi-z mode

    pio_sm_exec(dht->pio, dht->sm, pio_encode_set(pio_pindirs, 0));

    if (dma_channel_is_busy(dht->dma_chan))
    {

        dma_channel_abort(dht->dma_chan);

        return DHT_RESULT_TIMEOUT;
    }

    uint8_t checksum = dht->data[0] + dht->data[1] + dht->data[2] + dht->data[3];

    if (dht->data[4] != checksum)
    {

        return DHT_RESULT_BAD_CHECKSUM;
    }

    if (humidity != NULL)
    {

        *humidity = decode_humidity(dht->model, dht->data[0], dht->data[1]);
    }

    if (temperature_c != NULL)
    {

        *temperature_c = decode_temperature(dht->model, dht->data[2], dht->data[3]);
    }

    return DHT_RESULT_OK;
}

/**

 * ----------------------------------------------------------------------------------------------------

 * Macros

 * ----------------------------------------------------------------------------------------------------

 */

/* Clock */

#define PLL_SYS_KHZ (133 * 1000)

/* Buffer */

#define ETHERNET_BUF_MAX_SIZE (1024 * 2)

/* Socket */

#define SOCKET_MQTT 0

/* Port */

#define PORT_MQTT 1883

/* Timeout */

#define DEFAULT_TIMEOUT 1000 // 1 second

/* MQTT */

#define MQTT_CLIENT_ID "rpi-pico"

#define MQTT_USERNAME "wiznet"

#define MQTT_PASSWORD "0123456789"

#define MQTT_PUBLISH_TOPIC "publish_topic"

#define MQTT_PUBLISH_PAYLOAD "Hello, World!"

#define MQTT_PUBLISH_PERIOD (1000 * 10) // 10 seconds

#define MQTT_SUBSCRIBE_TOPIC "subscribe_topic"

#define MQTT_KEEP_ALIVE 60 // 60 milliseconds

/* DHT22 */

// change this to match your setup

static const dht_model_t DHT_MODEL = DHT22;

static const uint DATA_PIN = 28;

static float celsius_to_fahrenheit(float temperature)
{

    return temperature * (9.0f / 5) + 32;
}

/**

 * ----------------------------------------------------------------------------------------------------

 * Variables

 * ----------------------------------------------------------------------------------------------------

 */

/* Network */

static wiz_NetInfo g_net_info =

    {

        .mac = {0x00, 0x08, 0xDC, 0x12, 0x34, 0x56}, // MAC address

        .ip = {192, 168, 11, 2}, // IP address

        .sn = {255, 255, 255, 0}, // Subnet Mask

        .gw = {192, 168, 11, 1}, // Gateway

        .dns = {8, 8, 8, 8}, // DNS server

        .dhcp = NETINFO_STATIC // DHCP enable/disable

};

/* MQTT */

static uint8_t g_mqtt_send_buf[ETHERNET_BUF_MAX_SIZE] = {

    0,

};

static uint8_t g_mqtt_recv_buf[ETHERNET_BUF_MAX_SIZE] = {

    0,

};

static uint8_t g_mqtt_broker_ip[4] = {192, 168, 11, 229};

static Network g_mqtt_network;

static MQTTClient g_mqtt_client;

static MQTTPacket_connectData g_mqtt_packet_connect_data = MQTTPacket_connectData_initializer;

static MQTTMessage g_mqtt_message;

/* Timer  */

static volatile uint32_t g_msec_cnt = 0;

/**

 * ----------------------------------------------------------------------------------------------------

 * Functions

 * ----------------------------------------------------------------------------------------------------

 */

/* Clock */

static void set_clock_khz(void);

/* MQTT */

static void message_arrived(MessageData *msg_data);

/* Timer  */

static void repeating_timer_callback(void);

static time_t millis(void);

/**

 * ----------------------------------------------------------------------------------------------------

 * Main

 * ----------------------------------------------------------------------------------------------------

 */

int main()

{

    /* DHT 22 */

    stdio_init_all();

    char dht_string[600];

    char today_hot[500] = "Today's weather is Hot Summer! \nRecommended playlist: https://www.youtube.com/embed/Hf4A6O6q16c";
    char today_cold[500] = "Today's weather is Cold! \nRecommended playlist: https://www.youtube.com/embed/K81dHzC0T_M";
    char today_warm[500] = "Today's weather is Warm day! \nRecommended playlist: https://www.youtube.com/embed/DpcJP-wQWGI";

    dht_t dht;

    dht_init(&dht, DHT_MODEL, pio0, DATA_PIN, true /* pull_up */);

    /* Initialize */

    int32_t retval = 0;

    uint32_t start_ms = 0;

    uint32_t end_ms = 0;

    set_clock_khz();

    stdio_init_all();


sleep_ms(1000);
    wizchip_spi_initialize();

    wizchip_cris_initialize();

    wizchip_reset();

    wizchip_initialize();

    wizchip_check();

    wizchip_1ms_timer_initialize(repeating_timer_callback);

    network_initialize(g_net_info);

    /* Get network information */

    print_network_information(g_net_info);

    NewNetwork(&g_mqtt_network, SOCKET_MQTT);

    retval = ConnectNetwork(&g_mqtt_network, g_mqtt_broker_ip, PORT_MQTT);

    if (retval != 1)

    {

        printf(" Network connect failed\n");

        while (1)

            ;
    }

    /* Initialize MQTT client */

    MQTTClientInit(&g_mqtt_client, &g_mqtt_network, DEFAULT_TIMEOUT, g_mqtt_send_buf, ETHERNET_BUF_MAX_SIZE, g_mqtt_recv_buf, ETHERNET_BUF_MAX_SIZE);

    /* Connect to the MQTT broker */

    g_mqtt_packet_connect_data.MQTTVersion = 3;

    g_mqtt_packet_connect_data.cleansession = 1;

    g_mqtt_packet_connect_data.willFlag = 0;

    g_mqtt_packet_connect_data.keepAliveInterval = MQTT_KEEP_ALIVE;

    g_mqtt_packet_connect_data.clientID.cstring = MQTT_CLIENT_ID;

    g_mqtt_packet_connect_data.username.cstring = MQTT_USERNAME;

    g_mqtt_packet_connect_data.password.cstring = MQTT_PASSWORD;

    retval = MQTTConnect(&g_mqtt_client, &g_mqtt_packet_connect_data);

    if (retval < 0)

    {

        printf(" MQTT connect failed : %d\n", retval);

        while (1)

            ;
    }

    printf(" MQTT connected\n");

    /* Configure publish message */

    /* Subscribe */

    retval = MQTTSubscribe(&g_mqtt_client, MQTT_SUBSCRIBE_TOPIC, QOS0, message_arrived);

    if (retval < 0)

    {

        printf(" Subscribe failed : %d\n", retval);

        while (1)

            ;
    }

    printf(" Subscribed\n");

    start_ms = millis();

    /* Infinite loop */

    while (1)

    {

        if ((retval = MQTTYield(&g_mqtt_client, g_mqtt_packet_connect_data.keepAliveInterval)) < 0)

        {

            printf(" Yield error : %d\n", retval);

            while (1)

                ;
        }

        end_ms = millis();

        if (end_ms > start_ms + MQTT_PUBLISH_PERIOD)

        {

            /* Publish */

            dht_start_measurement(&dht);

            float humidity;

            float temperature_c;

            dht_result_t result = dht_finish_measurement_blocking(&dht, &humidity, &temperature_c);

            if (result == DHT_RESULT_OK)
            {
                snprintf(dht_string, sizeof(dht_string), "%.1f C (%.1f F), %.1f%% humidity\n",

                         temperature_c, celsius_to_fahrenheit(temperature_c), humidity);

                if(temperature_c > 30) strcat(dht_string, today_hot);
                else if (temperature_c < 10) strcat(dht_string, today_cold);
                else strcat(dht_string, today_warm);
                         
            }
            else if (result == DHT_RESULT_TIMEOUT)
            {

                puts("DHT sensor not responding. Please check your wiring.");
            }
            else
            {

                assert(result == DHT_RESULT_BAD_CHECKSUM);

                puts("Bad checksum");
            }

            g_mqtt_message.payload = dht_string;

            g_mqtt_message.qos = QOS0;

            g_mqtt_message.retained = 0;

            g_mqtt_message.dup = 0;

            g_mqtt_message.payloadlen = strlen(g_mqtt_message.payload);

            retval = MQTTPublish(&g_mqtt_client, MQTT_PUBLISH_TOPIC, &g_mqtt_message);

            if (retval < 0)

            {

                printf(" Publish failed : %d\n", retval);

                while (1)

                    ;
            }

            printf(" Published\n");

            start_ms = millis();
        }
    }
}

/**

 * ----------------------------------------------------------------------------------------------------

 * Functions

 * ----------------------------------------------------------------------------------------------------

 */

/* Clock */

static void set_clock_khz(void)

{

    // set a system clock frequency in khz

    set_sys_clock_khz(PLL_SYS_KHZ, true);

    // configure the specified clock

    clock_configure(

        clk_peri,

        0, // No glitchless mux

        CLOCKS_CLK_PERI_CTRL_AUXSRC_VALUE_CLKSRC_PLL_SYS, // System PLL on AUX mux

        PLL_SYS_KHZ * 1000, // Input frequency

        PLL_SYS_KHZ * 1000 // Output (must be same as no divider)

    );
}

/* MQTT */

static void message_arrived(MessageData *msg_data)

{

    MQTTMessage *message = msg_data->message;

    printf("%.*s", (uint32_t)message->payloadlen, (uint8_t *)message->payload);
}

/* Timer */

static void repeating_timer_callback(void)

{

    g_msec_cnt++;

    MilliTimer_Handler();
}

static time_t millis(void)

{

    return g_msec_cnt;
}
